// -*- C++ -*-
//===-------------------------- algorithm ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_MEMORY
#define _LIBCPP_EXPERIMENTAL_MEMORY

/*
namespace std {
template <class W> class observer_ptr {
public:
    // publish our template parameter and variations thereof
    using element_type = W;
    using pointer = add_pointer_t<W>; // exposition-only
    using reference = add_lvalue_reference_t<W>; // exposition-only

    // default c’tor
    constexpr observer_ptr() noexcept;

    // pointer-accepting c’tors
    constexpr observer_ptr(nullptr_t) noexcept;
    constexpr explicit observer_ptr(pointer) noexcept;

    // copying c’tors (in addition to compiler-generated copy c’tor)
    template <class W2> constexpr observer_ptr(observer_ptr<W2>) noexcept;

    // observers
    constexpr pointer get() const noexcept;
    constexpr reference operator*() const;
    constexpr pointer operator->() const noexcept;
    constexpr explicit operator bool() const noexcept;

    // conversions
    constexpr explicit operator pointer() const noexcept;

    // modifiers
    constexpr pointer release() noexcept;
    constexpr void reset(pointer = nullptr) noexcept;
    constexpr void swap(observer_ptr&) noexcept;
};
}
*/

#include <type_traits>
#include <functional>

#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>


_LIBCPP_BEGIN_NAMESPACE_STD // TODO: use _LIBCPP_BEGIN_NAMESPACE_LFTS?

template<class _Wp>
class observer_ptr
{
    typedef add_pointer_t<_Wp>          pointer;
    typedef add_lvalue_reference_t<_Wp> reference;

    pointer __ptr;

public:
    typedef _Wp                         element_type;

    // constructors
    constexpr observer_ptr() noexcept : __ptr(nullptr) { }
    constexpr observer_ptr(nullptr_t) noexcept : __ptr(nullptr) { }
    constexpr observer_ptr(pointer __p) noexcept : __ptr(__p) { }

    template<class _W2,
             class = enable_if_t<is_convertible<_W2*, _Wp*>::value>>
    constexpr observer_ptr(observer_ptr<_W2> __other) noexcept
        : __ptr(__other.get()) { }

    observer_ptr(observer_ptr const&) = default;
    observer_ptr(observer_ptr&&) = default;

    // observers
    constexpr pointer get() const noexcept { return __ptr; }
    constexpr reference operator*() const { return *__ptr; }
    constexpr pointer operator->() const noexcept { return __ptr; }
    constexpr explicit operator bool() const noexcept { return __ptr != nullptr; }

    // conversions
    constexpr /*explicit*/ operator pointer() const noexcept { return __ptr; }

    // modifiers
    constexpr void swap(observer_ptr& __other) noexcept { _VSTD::swap(__ptr, __other.__ptr); }
    constexpr void reset(pointer __p = nullptr) { __ptr = __p; }
    constexpr pointer release() noexcept
    {
        observer_ptr __p;
        __p.swap(*this);
        return __p.get();
    }
};

// specializations

template<class _Wp>
void swap(observer_ptr<_Wp>& __a, observer_ptr<_Wp>& __b)
{
    __a.swap(__b);
}

template<class _Wp>
observer_ptr<_Wp> make_observer(_Wp* __ptr)
{
    return observer_ptr<_Wp>{__ptr};
}

template<class _W1, class _W2>
bool operator==(observer_ptr<_W1> __a, observer_ptr<_W2> __b)
{
    return __a.get() == __b.get();
}

template<class _W1, class _W2>
bool operator!=(observer_ptr<_W1> __a, observer_ptr<_W2> __b)
{
    return !(__a == __b);
}

template<class _Wp>
bool operator==(observer_ptr<_Wp> __p, nullptr_t)
{
    return !__p;
}

template<class _Wp>
bool operator==(nullptr_t, observer_ptr<_Wp> __p)
{
    return !__p;
}

template<class _Wp>
bool operator!=(observer_ptr<_Wp> __p, nullptr_t)
{
    return (bool)__p;
}

template<class _Wp>
bool operator!=(nullptr_t, observer_ptr<_Wp> __p)
{
    return (bool)__p;
}

template<class _W1, class _W2>
bool operator<(observer_ptr<_W1> __a, observer_ptr<_W2> __b)
{
    return _VSTD::less<typename _VSTD::common_type<_W1*, _W2*>::type>()(__a.get(), __b.get());
}

template<class _W1, class _W2>
bool operator>(observer_ptr<_W1> __a, observer_ptr<_W2> __b)
{
    return __a < __b; // TODO: is this really correct?
}

template<class _W1, class _W2>
bool operator<=(observer_ptr<_W1> __a, observer_ptr<_W2> __b)
{
    return !(__a > __b);
}

template<class _W1, class _W2>
bool operator>=(observer_ptr<_W1> __a, observer_ptr<_W2> __b)
{
    return !(__a < __b);
}

// hash

template<class _Tp>
struct hash<observer_ptr<_Tp>>
{
    typedef observer_ptr<_Tp>    argument_type;
    typedef size_t               result_type;

    _LIBCPP_INLINE_VISIBILITY
    result_type operator()(const argument_type& __ptr) const noexcept
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif /* _LIBCPP_EXPERIMENTAL_MEMORY */
